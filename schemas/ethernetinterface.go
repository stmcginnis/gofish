//
// SPDX-License-Identifier: BSD-3-Clause
//

// http://redfish.dmtf.org/schemas/v1/EthernetInterface.v1_12_4.json
// 2023.3 - #EthernetInterface.v1_12_4.EthernetInterface

package schemas

import (
	"encoding/json"
)

type DHCPFallback string

const (
	// StaticDHCPFallback shall fall back to a static address specified by
	// 'IPv4StaticAddresses'.
	StaticDHCPFallback DHCPFallback = "Static"
	// AutoConfigDHCPFallback shall fall back to an address generated by the
	// implementation.
	AutoConfigDHCPFallback DHCPFallback = "AutoConfig"
	// NoneDHCPFallback shall continue trying to obtain an address without falling
	// back to a fixed address.
	NoneDHCPFallback DHCPFallback = "None"
)

type DHCPv6OperatingMode string

const (
	// StatefulDHCPv6OperatingMode shall operate in stateful mode on this
	// interface. DHCPv6 stateful mode configures addresses, and when it is
	// enabled, stateless mode is also implicitly enabled. Services may replace
	// this value with 'Enabled'.
	StatefulDHCPv6OperatingMode DHCPv6OperatingMode = "Stateful"
	// StatelessDHCPv6OperatingMode shall operate in stateless mode on this
	// interface. DHCPv6 stateless mode allows configuring the interface using DHCP
	// options but does not configure addresses. It is always enabled by default
	// whenever DHCPv6 stateful mode is also enabled. Services may replace this
	// value with 'Enabled'.
	StatelessDHCPv6OperatingMode DHCPv6OperatingMode = "Stateless"
	// DisabledDHCPv6OperatingMode shall be disabled for this interface.
	DisabledDHCPv6OperatingMode DHCPv6OperatingMode = "Disabled"
	// EnabledDHCPv6OperatingMode shall be enabled for this interface.
	EnabledDHCPv6OperatingMode DHCPv6OperatingMode = "Enabled"
)

type EthernetDeviceType string

const (
	// PhysicalEthernetDeviceType shall indicate a physical traditional network
	// interface.
	PhysicalEthernetDeviceType EthernetDeviceType = "Physical"
	// VirtualEthernetDeviceType shall indicate a network device function has
	// multiple VLANs and is representing one of them as a virtual Ethernet
	// interface. The 'NetworkDeviceFunction' property within Links shall contain
	// the locator for the parent network device function.
	VirtualEthernetDeviceType EthernetDeviceType = "Virtual"
)

type LinkStatus string

const (
	// LinkUpLinkStatus The link is available for communication on this interface.
	LinkUpLinkStatus LinkStatus = "LinkUp"
	// NoLinkLinkStatus No link or connection is detected on this interface.
	NoLinkLinkStatus LinkStatus = "NoLink"
	// LinkDownLinkStatus No link is detected on this interface, but the interface
	// is connected.
	LinkDownLinkStatus LinkStatus = "LinkDown"
)

type RoutingScope string

const (
	// ExternalRoutingScope shall indicate this interface is externally accessible
	// as if it were physically on the same network as the hosting system.
	ExternalRoutingScope RoutingScope = "External"
	// HostOnlyRoutingScope shall indicate this interface is only accessible to a
	// dedicated interface on the hosting system.
	HostOnlyRoutingScope RoutingScope = "HostOnly"
	// InternalRoutingScope shall indicate this interface is only accessible to
	// internal networking on the host, such as when virtual machines or containers
	// are allowed to communicate with each other on the same host system as well
	// as a dedicated interface on the hosting system.
	InternalRoutingScope RoutingScope = "Internal"
	// LimitedRoutingScope shall indicate this interface is accessible through IP
	// translation provided by the hosting system, such as a NAT (network address
	// translation).
	LimitedRoutingScope RoutingScope = "Limited"
)

type TeamMode string

const (
	// NoneTeamMode No teaming.
	NoneTeamMode TeamMode = "None"
	// RoundRobinTeamMode Packets are transmitted in sequential order from the
	// teamed interfaces.
	RoundRobinTeamMode TeamMode = "RoundRobin"
	// ActiveBackupTeamMode One interface in the team is active and the others are
	// kept in standby until a failure occurs.
	ActiveBackupTeamMode TeamMode = "ActiveBackup"
	// XORTeamMode Transmitting is determined based upon a hash policy.
	XORTeamMode TeamMode = "XOR"
	// BroadcastTeamMode Packets are transmitted on all interfaces in the team.
	BroadcastTeamMode TeamMode = "Broadcast"
	// IEEE8023adTeamMode The interfaces in the team create an IEEE802.3ad link
	// aggregation group.
	IEEE8023adTeamMode TeamMode = "IEEE802_3ad"
	// AdaptiveTransmitLoadBalancingTeamMode Packets are transmitted based upon the
	// current load of each interface in the team.
	AdaptiveTransmitLoadBalancingTeamMode TeamMode = "AdaptiveTransmitLoadBalancing"
	// AdaptiveLoadBalancingTeamMode Packets are transmitted and received based
	// upon the current load of each interface in the team.
	AdaptiveLoadBalancingTeamMode TeamMode = "AdaptiveLoadBalancing"
)

// EthernetInterface This resource contains NIC resources as part of the Redfish
// Specification.
type EthernetInterface struct {
	Entity
	// AutoNeg shall indicate whether the speed and duplex are automatically
	// negotiated and configured on this interface.
	AutoNeg bool
	// DHCPv4 shall contain the configuration of DHCP v4.
	//
	// Version added: v1.4.0
	DHCPv4 DHCPv4Configuration
	// DHCPv6 shall contain the configuration of DHCP v6.
	//
	// Version added: v1.4.0
	DHCPv6 DHCPv6Configuration
	// EthernetInterfaceType shall contain the type of interface.
	//
	// Version added: v1.6.0
	EthernetInterfaceType EthernetDeviceType
	// FQDN shall contain the fully qualified domain name that DNS obtains for this
	// interface.
	FQDN string
	// FullDuplex shall indicate whether full-duplex mode is enabled on the
	// Ethernet connection for this interface.
	FullDuplex bool
	// HostName shall contain the DNS host name for this interface. Modifying this
	// property may modify the 'HostName' in one or more 'EthernetInterface'
	// resources that belong to the same system, manager, or other device. If this
	// interface is subordinate to a 'ComputerSystem' resource, modifying this
	// property may modify the 'HostName' of the 'ComputerSystem' resource that
	// contains this interface. If this interface is subordinate to a 'Manager'
	// resource, modifying this property may modify the 'HostName' of the
	// 'ManagerNetworkProtocol' resource of the 'Manager' resource that contains
	// this interface. Services should ignore this property in modification
	// requests if 'FQDN' is also provided in the same request.
	HostName string
	// IPv4Addresses shall contain an array of objects that represent the IPv4
	// connection characteristics currently in use by this interface for any value
	// of 'AddressOrigin'. It is recommended that this property be regarded as
	// read-only with configuration of static addresses performed by updating the
	// values within 'IPv4StaticAddresses'. Services may reject updates to this
	// array for this reason. This property should contain an empty array if there
	// are no active IPv4 addresses.
	IPv4Addresses []IPv4Address
	// IPv4StaticAddresses shall contain an array of objects that represent all
	// IPv4 static addresses assigned to, but not necessarily in use by, this
	// interface. The 'IPv4Addresses' property shall also list the addresses that
	// this interface uses. Services should represent static addresses that are not
	// configured as 'null' values, as described by the 'PATCH on array properties'
	// clause of the Redfish Specification. Services should not represent static
	// addresses that are not configured as invalid IP addresses, such as
	// '0.0.0.0'.
	//
	// Version added: v1.4.0
	IPv4StaticAddresses []IPv4Address
	// IPv6AddressPolicyTable shall contain an array of objects that represent the
	// RFC6724-defined address selection policy table.
	IPv6AddressPolicyTable []IPv6AddressPolicyEntry
	// IPv6Addresses shall contain an array of objects that represent the IPv6
	// connection characteristics for this interface for any value of
	// 'AddressOrigin'. This property should contain an empty array if there are no
	// active IPv6 addresses.
	IPv6Addresses []IPv6Address
	// IPv6DefaultGateway shall contain the current IPv6 default gateway address in
	// use on this interface.
	IPv6DefaultGateway string
	// IPv6Enabled shall indicate whether IPv6 is enabled on this interface. If
	// this property contains 'false', the interface shall not contain any assigned
	// IPv6 addresses, shall not initiate DHCPv6 requests, and shall not send or
	// process ICMPv6 packets. If this property is not present, but this interface
	// contains other IPv6 properties, the value shall be assumed to be 'true'.
	//
	// Version added: v1.12.0
	IPv6Enabled bool
	// IPv6StaticAddresses shall contain an array of objects that represent the
	// IPv6 static connection characteristics for this interface. Services should
	// represent static addresses that are not configured as 'null' values, as
	// described by the 'PATCH on array properties' clause of the Redfish
	// Specification. Services should not represent static addresses that are not
	// configured as invalid IP addresses, such as '::'.
	IPv6StaticAddresses []IPv6StaticAddress
	// IPv6StaticDefaultGateways shall represent the IPv6 static default gateway
	// addresses for this interface.
	//
	// Version added: v1.4.0
	IPv6StaticDefaultGateways []IPv6GatewayStaticAddress
	// InterfaceEnabled shall indicate whether this interface is enabled. If this
	// interface is also a host interface, modifying this property may modify the
	// 'InterfaceEnabled' property in the 'HostInterface' resource for this
	// interface.
	InterfaceEnabled bool
	// LinkStatus shall contain the link status of this interface, or port.
	//
	// Version added: v1.1.0
	LinkStatus LinkStatus
	// MACAddress shall contain the effective current MAC address of this
	// interface. If an assignable MAC address is not supported, this value is a
	// read-only alias of the PermanentMACAddress.
	MACAddress string
	// MTUSize shall contain the size, in bytes, of the largest protocol data unit
	// (PDU) that can be passed in an Ethernet (MAC) frame on this interface, as
	// currently configured by the operating system or driver.
	MTUSize *int `json:",omitempty"`
	// MaxIPv6StaticAddresses shall indicate the number of array items supported by
	// 'IPv6StaticAddresses', or the maximum number of static IPv6 addresses that
	// can be configured on this interface.
	MaxIPv6StaticAddresses *int `json:",omitempty"`
	// NameServers shall contain the DNS servers in use on this interface.
	NameServers []string
	// ODataContext is the odata context.
	ODataContext string `json:"@odata.context"`
	// ODataType is the odata type.
	ODataType string `json:"@odata.type"`
	// OEM shall contain the OEM extensions. All values for properties that this
	// object contains shall conform to the Redfish Specification-described
	// requirements.
	OEM json.RawMessage `json:"Oem"`
	// PermanentMACAddress shall contain the permanent MAC address of this
	// interface, or port. Typically, this value is programmed during
	// manufacturing. This address is not assignable.
	PermanentMACAddress string
	// RoutingScope shall contain the routing scope for this interface. This
	// property shall only be present if this interface belongs to a virtual
	// machine or container.
	//
	// Version added: v1.11.0
	RoutingScope RoutingScope
	// SpeedMbps shall contain the link speed of the interface, in megabits per
	// second (Mbit/s) units. This property shall be writable only when the
	// 'AutoNeg' property is 'false'.
	SpeedMbps *int `json:",omitempty"`
	// StatelessAddressAutoConfig shall contain the IPv4 and IPv6 stateless address
	// automatic configuration (SLAAC) properties for this interface.
	//
	// Version added: v1.4.0
	StatelessAddressAutoConfig StatelessAddressAutoConfiguration
	// StaticNameServers shall contain the statically-defined set of DNS server IP
	// addresses to use when DHCP provisioning is not enabled for name server
	// configuration. As an implementation option, they can be used in addition to
	// DHCP-provided addresses, or in cases where the DHCP server provides no DNS
	// assignments.
	//
	// Version added: v1.4.0
	StaticNameServers []string
	// Status shall contain any status or health properties of the resource.
	Status Status
	// TeamMode shall contain the team mode for this interface. If this property is
	// not present, the value shall be assumed to be 'None'.
	//
	// Version added: v1.9.0
	TeamMode TeamMode
	// UefiDevicePath shall contain the UEFI device path to the device that
	// implements this interface, or port.
	UefiDevicePath string
	// VLAN shall contain the VLAN for this interface. If this interface supports
	// more than one VLAN, the 'VLAN' property shall be absent and, instead, the
	// VLAN collection link shall be present.
	VLAN VLAN
	// VLANs shall contain a link to a resource collection of type
	// 'VLanNetworkInterfaceCollection', which applies only if the interface
	// supports more than one VLAN. If this property is present, the 'VLANEnabled'
	// and 'VLANId' properties shall not be present.
	//
	// Deprecated: v1.7.0
	// This property has been deprecated in favor of newer methods indicating
	// multiple VLANs.
	vLANs string
	// affiliatedInterfaces are the URIs for AffiliatedInterfaces.
	affiliatedInterfaces []string
	// chassis is the URI for Chassis.
	chassis string
	// endpoints are the URIs for Endpoints.
	endpoints []string
	// hostInterface is the URI for HostInterface.
	hostInterface string
	// networkDeviceFunction is the URI for NetworkDeviceFunction.
	networkDeviceFunction string
	// networkDeviceFunctions are the URIs for NetworkDeviceFunctions.
	networkDeviceFunctions []string
	// ports are the URIs for Ports.
	ports []string
	// relatedInterfaces are the URIs for RelatedInterfaces.
	relatedInterfaces []string
	// RawData holds the original serialized JSON so we can compare updates.
	RawData []byte
}

// UnmarshalJSON unmarshals a EthernetInterface object from the raw JSON.
func (e *EthernetInterface) UnmarshalJSON(b []byte) error {
	type temp EthernetInterface
	type eLinks struct {
		AffiliatedInterfaces   Links `json:"AffiliatedInterfaces"`
		Chassis                Link  `json:"Chassis"`
		Endpoints              Links `json:"Endpoints"`
		HostInterface          Link  `json:"HostInterface"`
		NetworkDeviceFunction  Link  `json:"NetworkDeviceFunction"`
		NetworkDeviceFunctions Links `json:"NetworkDeviceFunctions"`
		Ports                  Links `json:"Ports"`
		RelatedInterfaces      Links `json:"RelatedInterfaces"`
	}
	var tmp struct {
		temp
		Links eLinks
		VLANs Link `json:"VLANs"`
	}

	err := json.Unmarshal(b, &tmp)
	if err != nil {
		return err
	}

	*e = EthernetInterface(tmp.temp)

	// Extract the links to other entities for later
	e.affiliatedInterfaces = tmp.Links.AffiliatedInterfaces.ToStrings()
	e.chassis = tmp.Links.Chassis.String()
	e.endpoints = tmp.Links.Endpoints.ToStrings()
	e.hostInterface = tmp.Links.HostInterface.String()
	e.networkDeviceFunction = tmp.Links.NetworkDeviceFunction.String()
	e.networkDeviceFunctions = tmp.Links.NetworkDeviceFunctions.ToStrings()
	e.ports = tmp.Links.Ports.ToStrings()
	e.relatedInterfaces = tmp.Links.RelatedInterfaces.ToStrings()
	e.vLANs = tmp.VLANs.String()

	// This is a read/write object, so we need to save the raw object data for later
	e.RawData = b

	return nil
}

// Update commits updates to this object's properties to the running system.
func (e *EthernetInterface) Update() error {
	readWriteFields := []string{
		"AutoNeg",
		"DHCPv4",
		"DHCPv6",
		"FQDN",
		"FullDuplex",
		"HostName",
		"IPv4Addresses",
		"IPv4StaticAddresses",
		"IPv6AddressPolicyTable",
		"IPv6Addresses",
		"IPv6Enabled",
		"IPv6StaticAddresses",
		"IPv6StaticDefaultGateways",
		"InterfaceEnabled",
		"MACAddress",
		"MTUSize",
		"SpeedMbps",
		"StatelessAddressAutoConfig",
		"StaticNameServers",
		"Status",
		"TeamMode",
		"VLAN",
	}

	return e.UpdateFromRawData(e, e.RawData, readWriteFields)
}

// GetEthernetInterface will get a EthernetInterface instance from the service.
func GetEthernetInterface(c Client, uri string) (*EthernetInterface, error) {
	return GetObject[EthernetInterface](c, uri)
}

// ListReferencedEthernetInterfaces gets the collection of EthernetInterface from
// a provided reference.
func ListReferencedEthernetInterfaces(c Client, link string) ([]*EthernetInterface, error) {
	return GetCollectionObjects[EthernetInterface](c, link)
}

// AffiliatedInterfaces gets the AffiliatedInterfaces linked resources.
func (e *EthernetInterface) AffiliatedInterfaces() ([]*EthernetInterface, error) {
	return GetObjects[EthernetInterface](e.client, e.affiliatedInterfaces)
}

// Chassis gets the Chassis linked resource.
func (e *EthernetInterface) Chassis() (*Chassis, error) {
	if e.chassis == "" {
		return nil, nil
	}
	return GetObject[Chassis](e.client, e.chassis)
}

// Endpoints gets the Endpoints linked resources.
func (e *EthernetInterface) Endpoints() ([]*Endpoint, error) {
	return GetObjects[Endpoint](e.client, e.endpoints)
}

// HostInterface gets the HostInterface linked resource.
func (e *EthernetInterface) HostInterface() (*HostInterface, error) {
	if e.hostInterface == "" {
		return nil, nil
	}
	return GetObject[HostInterface](e.client, e.hostInterface)
}

// NetworkDeviceFunction gets the NetworkDeviceFunction linked resource.
func (e *EthernetInterface) NetworkDeviceFunction() (*NetworkDeviceFunction, error) {
	if e.networkDeviceFunction == "" {
		return nil, nil
	}
	return GetObject[NetworkDeviceFunction](e.client, e.networkDeviceFunction)
}

// NetworkDeviceFunctions gets the NetworkDeviceFunctions linked resources.
func (e *EthernetInterface) NetworkDeviceFunctions() ([]*NetworkDeviceFunction, error) {
	return GetObjects[NetworkDeviceFunction](e.client, e.networkDeviceFunctions)
}

// Ports gets the Ports linked resources.
func (e *EthernetInterface) Ports() ([]*Port, error) {
	return GetObjects[Port](e.client, e.ports)
}

// RelatedInterfaces gets the RelatedInterfaces linked resources.
func (e *EthernetInterface) RelatedInterfaces() ([]*EthernetInterface, error) {
	return GetObjects[EthernetInterface](e.client, e.relatedInterfaces)
}

// VLANs gets the VLANs collection.
func (e *EthernetInterface) VLANs() ([]*VLanNetworkInterface, error) {
	if e.vLANs == "" {
		return nil, nil
	}
	return GetCollectionObjects[VLanNetworkInterface](e.client, e.vLANs)
}

// DHCPv4Configuration shall describe the configuration of DHCP v4.
type DHCPv4Configuration struct {
	// DHCPEnabled shall indicate whether DHCP v4 is enabled for this Ethernet
	// interface.
	//
	// Version added: v1.4.0
	DHCPEnabled bool
	// FallbackAddress shall contain the fallback address method of DHCPv4.
	//
	// Version added: v1.5.0
	FallbackAddress DHCPFallback
	// UseDNSServers shall indicate whether the interface uses DHCP v4-supplied DNS
	// servers.
	//
	// Version added: v1.4.0
	UseDNSServers bool
	// UseDomainName shall indicate whether the interface uses a DHCP v4-supplied
	// domain name.
	//
	// Version added: v1.4.0
	UseDomainName bool
	// UseGateway shall indicate whether the interface uses a DHCP v4-supplied
	// gateway.
	//
	// Version added: v1.4.0
	UseGateway bool
	// UseNTPServers shall indicate whether the interface uses DHCP v4-supplied NTP
	// servers.
	//
	// Version added: v1.4.0
	UseNTPServers bool
	// UseStaticRoutes shall indicate whether the interface uses a DHCP v4-supplied
	// static routes.
	//
	// Version added: v1.4.0
	UseStaticRoutes bool
}

// DHCPv6Configuration shall describe the configuration of DHCP v6.
type DHCPv6Configuration struct {
	// OperatingMode shall control the operating mode of DHCPv6 on this interface.
	//
	// Version added: v1.4.0
	OperatingMode DHCPv6OperatingMode
	// UseDNSServers shall indicate whether the interface uses DHCP v6-supplied DNS
	// servers.
	//
	// Version added: v1.4.0
	UseDNSServers bool
	// UseDomainName shall indicate whether the interface uses a DHCP v6-supplied
	// domain name.
	//
	// Version added: v1.4.0
	UseDomainName bool
	// UseNTPServers shall indicate whether the interface uses DHCP v6-supplied NTP
	// servers.
	//
	// Version added: v1.4.0
	UseNTPServers bool
	// UseRapidCommit shall indicate whether the interface uses DHCP v6 rapid
	// commit mode for stateful mode address assignments.
	//
	// Version added: v1.4.0
	UseRapidCommit bool
}

// IPv6AddressPolicyEntry shall describe an entry in the RFC6724-defined address
// selection policy table.
type IPv6AddressPolicyEntry struct {
	// Label shall contain the IPv6 label value for this table entry, as defined in
	// RFC6724, section 2.1.
	Label *uint `json:",omitempty"`
	// Precedence shall contain the IPv6 precedence value for this table entry, as
	// defined in RFC6724, section 2.1.
	Precedence *uint `json:",omitempty"`
	// Prefix shall contain the IPv6 address prefix for this table entry, as
	// defined in RFC6724, section 2.1.
	Prefix string
}

// StatelessAddressAutoConfiguration shall describe the IPv4 and IPv6 stateless
// address autoconfiguration (SLAAC) for this interface.
type StatelessAddressAutoConfiguration struct {
	// IPv4AutoConfigEnabled shall indicate whether IPv4 stateless address
	// autoconfiguration (SLAAC) is enabled for this interface.
	//
	// Version added: v1.4.0
	IPv4AutoConfigEnabled bool
	// IPv6AutoConfigEnabled shall indicate whether IPv6 stateless address
	// autoconfiguration (SLAAC) is enabled for this interface.
	//
	// Version added: v1.4.0
	IPv6AutoConfigEnabled bool
}
