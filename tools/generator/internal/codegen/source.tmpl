//
// SPDX-License-Identifier: BSD-3-Clause
//
{{- if and .Release .Title }}
// {{ .Release }} - {{ .Title }}
{{- end }}

package {{ .Package }}

{{- if .ImportGroups }}

import (
{{- range $gi, $group := .ImportGroups }}
{{- if $gi }}

{{- end }}
{{- range $group }}
	"{{ . }}"
{{- end }}
{{- end }}
)
{{- end }}
{{- $pkg := "" }}
{{- if eq .Package "gofish" }}
{{- $pkg = "schemas." }}
{{- end }}
{{- range .Enums }}

{{- if ne .Description "" }}
{{ .Description }}
{{- end }}
type {{ .Name }} string

const (
{{- $enumType := .Name }}
{{- range .Values }}
{{ .Description }}
	{{ .Name }} {{ $enumType }} = "{{ .Value }}"
{{- end }}
)
{{- end }}
{{- range .Structs }}
{{- $structName := .Name }}
{{- $receiverName := .ReceiverName }}

{{ .Description }}
type {{ .Name }} struct {
{{- if .IsEntity }}
	{{ $pkg }}Entity
{{- end }}
{{- range .Properties }}
{{ .Description }}
	{{ .Name }} {{ .TypeString }} {{ .JSONTag }}
{{- end }}
{{- range .Actions }}
	// {{ .TargetField }} is the URL to send {{ .Name }} requests.
	{{ .TargetField }} string
{{- end }}
{{- range .Links }}
	// {{ .FieldName }} {{- if .IsArray }} are the URIs{{ else }} is the URI{{ end }} for {{ .Name }}.
	{{ .FieldName }} {{if .IsArray}}[]string{{else}}string{{end}}
{{- end }}
{{- if and .IsEntity (gt (len .ReadWriteProperties) 0) }}
	// RawData holds the original serialized JSON so we can compare updates.
	RawData []byte
{{- end }}
}
{{- if or (and .IsEntity (gt (len .ReadWriteProperties) 0)) .HasActions .HasLinks .HasLinkProperties }}

// UnmarshalJSON unmarshals a {{ .Name }} object from the raw JSON.
func ({{ .ReceiverName }} *{{ .Name }}) UnmarshalJSON(b []byte) error {
	type temp {{ .Name }}
{{- if .HasActions }}
	type {{ .ReceiverName }}Actions struct {
{{- range .Actions }}
		{{ .Name }} {{ $pkg }}ActionTarget `json:"{{ .JSONName }}"`
{{- end }}
	}
{{- end }}
{{- if .HasLinks }}
	type {{ .ReceiverName }}Links struct {
{{- range .Links }}
{{- if .IsArray }}
		{{ .Name }} {{ $pkg }}Links `json:"{{ .JSONName }}"`
{{- else }}
		{{ .Name }} {{ $pkg }}Link `json:"{{ .JSONName }}"`
{{- end }}
{{- end }}
	}
{{- end }}
	var tmp struct {
		temp
{{- if .HasActions }}
		Actions {{ .ReceiverName }}Actions
{{- end }}
{{- if .HasLinks }}
		Links {{ .ReceiverName }}Links
{{- end }}
{{- range .Properties }}
{{- if and .IsLink .LinkType }}
{{- if .IsArray }}
		{{ .GetterMethod }} {{ $pkg }}Links `json:"{{ .JSONName }}"`
{{- else }}
		{{ .GetterMethod }} {{ $pkg }}Link `json:"{{ .JSONName }}"`
{{- end }}
{{- end }}
{{- end }}
	}

	err := json.Unmarshal(b, &tmp)
	if err != nil {
		return err
	}

	*{{ .ReceiverName }} = {{ .Name }}(tmp.temp)

	// Extract the links to other entities for later
{{- range .Actions }}
	{{ $receiverName }}.{{ .TargetField }} = tmp.Actions.{{ .Name }}.Target
{{- end }}
{{- range .Links }}
{{- if .IsArray }}
	{{ $receiverName }}.{{ .FieldName }} = tmp.Links.{{ .Name }}.ToStrings()
{{- else }}
	{{ $receiverName }}.{{ .FieldName }} = tmp.Links.{{ .Name }}.String()
{{- end }}
{{- end }}
{{- range .Properties }}
{{- if and .IsLink .LinkType }}
{{- if .IsArray }}
	{{ $receiverName }}.{{ .Name }} = tmp.{{ .GetterMethod }}.ToStrings()
{{- else }}
	{{ $receiverName }}.{{ .Name }} = tmp.{{ .GetterMethod }}.String()
{{- end }}
{{- end }}
{{- end }}
{{- if and .IsEntity (gt (len .ReadWriteProperties) 0) }}

	// This is a read/write object, so we need to save the raw object data for later
	{{ .ReceiverName }}.RawData = b
{{- end }}

	return nil
}
{{- end }}
{{- if and .IsEntity (gt (len .ReadWriteProperties) 0) }}

// Update commits updates to this object's properties to the running system.
func ({{ .ReceiverName }} *{{ .Name }}) Update() error {
	readWriteFields := []string{

{{- range .ReadWriteProperties }}
		"{{ . }}",
{{- end }}
	}

	return {{ .ReceiverName }}.UpdateFromRawData({{ .ReceiverName }}, {{ .ReceiverName }}.RawData, readWriteFields)
}
{{- end }}
{{- if .IsEntity }}

// Get{{ .Name }} will get a {{ .Name }} instance from the service.
func Get{{ .Name }}(c {{ $pkg }}Client, uri string) (*{{ .Name }}, error) {
	return {{ $pkg }}GetObject[{{ .Name }}](c, uri)
}

// ListReferenced{{ .Name }}s gets the collection of {{ .Name }} from
// a provided reference.
func ListReferenced{{ .Name }}s(c {{ $pkg }}Client, link string) ([]*{{ .Name }}, error) {
	return {{ $pkg }}GetCollectionObjects[{{ .Name }}](c, link)
}
{{- end }}
{{- range .Actions }}
{{- if .UseParamStruct }}

// {{ .ParamStructName }} holds the parameters for the {{ .Name }} action.
type {{ .ParamStructName }} struct {
{{- range .Parameters }}
{{ .FieldDescription }}
	{{ .FieldName }} {{ .Type }} {{ .JSONTag }}
{{- end }}
}
{{- end }}

{{ .Description }}
{{- if not .UseParamStruct }}
{{- range $i, $p := .Parameters }}
{{ $p.Description }}
{{- end }}
{{- end }}
{{- if .ResponseType }}
{{- if .UseParamStruct }}
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}(params *{{ .ParamStructName }}) (*{{ .ResponseType }}, error) {
	resp, err := {{ $receiverName }}.PostWithResponse({{ $receiverName }}.{{ .TargetField }}, params)
{{- else }}
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}({{- range $i, $p := .Parameters }}{{- if $i }}, {{ end }}{{ $p.Name }} {{ $p.Type }}{{- end }}) (*{{ .ResponseType }}, error) {
	payload := make(map[string]any)
{{- range .Parameters }}
	payload["{{ .OriginalName }}"] = {{ .Name }}
{{- end }}

	resp, err := {{ $receiverName }}.PostWithResponse({{ $receiverName }}.{{ .TargetField }}, payload)
{{- end }}
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, {{ $pkg }}CleanupHTTPResponse(resp)
	}

	var result {{ .ResponseType }}
	err = json.NewDecoder(resp.Body).Decode(&result)
	if err != nil {
		return nil, err
	}

	return &result, nil
}
{{- else }}
//
// If TaskMonitorInfo is not nil it can be used to monitor async tasks.
{{- if .UseParamStruct }}
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}(params *{{ .ParamStructName }}) (*TaskMonitorInfo, error) {
	resp, taskInfo, err := PostWithTask({{ $receiverName }}.client,
		{{ $receiverName }}.{{ .TargetField }}, params, {{ $receiverName }}.Headers(), false)
{{- else }}
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}({{- range $i, $p := .Parameters }}{{- if $i }}, {{ end }}{{ $p.Name }} {{ $p.Type }}{{- end }}) (*TaskMonitorInfo, error) {
	payload := make(map[string]any)
{{- range .Parameters }}
	payload["{{ .OriginalName }}"] = {{ .Name }}
{{- end }}
	resp, taskInfo, err := PostWithTask({{ $receiverName }}.client,
		{{ $receiverName }}.{{ .TargetField }}, payload, {{ $receiverName }}.Headers(), false)
{{- end }}
	defer DeferredCleanupHTTPResponse(resp)
	return taskInfo, err
}
{{- end }}
{{- end }}
{{- $client := printf "client %sClient" $pkg }}
{{- $getClient := "client" }}
{{- if .IsEntity }}
{{- $client = "" }}
{{- $getClient = printf "%s.client" $receiverName }}
{{- if eq $pkg "schemas." }}
{{- $getClient = printf "%s.GetClient()" $receiverName }}
{{- end }}
{{- end }}
{{- range .Links }}
{{- if .IsArray }}

// {{ .Name }} gets the {{ .Name }} linked resources.
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}({{ $client }}) ([]*{{ .Type }}, error) {
	return {{ $pkg }}GetObjects[{{ .Type }}]({{ $getClient }}, {{ $receiverName }}.{{ .FieldName }})
}
{{- else }}

// {{ .Name }} gets the {{ .Name }} linked resource.
func ({{ $receiverName }} *{{ $structName }}) {{ .Name }}({{ $client }}) (*{{ .Type }}, error) {
	if {{ $receiverName }}.{{ .FieldName }} == "" {
		return nil, nil
	}
	return {{ $pkg }}GetObject[{{ .Type }}]({{ $getClient }}, {{ $receiverName }}.{{ .FieldName }})
}
{{- end }}
{{- end }}
{{- range .Properties }}
{{- if and .IsLink .LinkType }}
{{- if .IsCollection }}

// {{ .GetterMethod }} gets the {{ .GetterMethod }} collection.
func ({{ $receiverName }} *{{ $structName }}) {{ .GetterMethod }}({{ $client }}) ([]*{{ .LinkType }}, error) {
	if {{ $receiverName }}.{{ .Name }} == "" {
		return nil, nil
	}
	return {{ $pkg }}GetCollectionObjects[{{ .LinkType }}]({{ $getClient }}, {{ $receiverName }}.{{ .Name }})
}
{{- else if .IsArray }}

// {{ .GetterMethod }} gets the {{ .GetterMethod }} linked resources.
func ({{ $receiverName }} *{{ $structName }}) {{ .GetterMethod }}({{ $client }}) ([]*{{ .LinkType }}, error) {
	return {{ $pkg }}GetObjects[{{ .LinkType }}]({{ $getClient }}, {{ $receiverName }}.{{ .Name }})
}
{{- else }}

// {{ .GetterMethod }} gets the {{ .GetterMethod }} linked resource.
func ({{ $receiverName }} *{{ $structName }}) {{ .GetterMethod }}({{ $client }}) (*{{ .LinkType }}, error) {
	if {{ $receiverName }}.{{ .Name }} == "" {
		return nil, nil
	}
	return {{ $pkg }}GetObject[{{ .LinkType }}]({{ $getClient }}, {{ $receiverName }}.{{ .Name }})
}
{{- end }}
{{- end }}
{{- end }}
{{- end }}
